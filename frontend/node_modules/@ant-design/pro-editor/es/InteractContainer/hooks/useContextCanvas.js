import { useEffect } from 'react';
import { useContainer } from "./useContainer";
import { useInteraction } from "./useInteraction";
import { useInteractModel } from "./useInteractModel";
import { useInteractStatus } from "./useInteractStatus";
import { useRender } from "./useRender";
export var useContextCanvas = function useContextCanvas(_ref) {
  var rules = _ref.rules,
    outStatus = _ref.status,
    onStatusChange = _ref.onStatusChange,
    getContainer = _ref.getContainer,
    disabled = _ref.disabled;
  var Render = useRender();
  var container = useContainer(getContainer);
  var interactModel = useInteractModel(rules, container);
  var _useInteractStatus = useInteractStatus(interactModel, {
      value: outStatus,
      onChange: onStatusChange
    }),
    status = _useInteractStatus.status,
    dispatchStatus = _useInteractStatus.dispatchStatus;
  var renderByStatus = function renderByStatus(interactStatus) {
    if (!interactStatus) {
      Render.renderUnselectedAll();
      return;
    }
    var element = interactModel.getElementByStatus(interactStatus);
    switch (interactStatus.status) {
      case 'selected':
        Render.renderUnselectedAll();
        Render.renderSelected(element);
        break;
      case 'unSelected':
        {
          if (element) {
            Render.renderUnselected(element);
          } else {
            Render.renderUnselectedAll();
          }
          break;
        }
      case 'hover':
        Render.renderHover(element);
        break;
      case 'unhover':
        Render.renderUnHover();
        break;
    }
  };

  // 用回调的方式来做渲染控制，便于统一受控和非受控模式
  useEffect(function () {
    renderByStatus(status);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [status]);
  var _useInteraction = useInteraction({
      container: container,
      interactModel: interactModel,
      dispatchStatus: dispatchStatus,
      disabled: disabled
    }),
    onClick = _useInteraction.onClick;
  return {
    onClick: onClick
  };
};