import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
var _excluded = ["items", "label", "container"];
import { autoUpdate, flip, FloatingFocusManager, FloatingNode, FloatingPortal, FloatingTree, offset, safePolygon, shift, useClick, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingTree, useHover, useInteractions, useListNavigation, useMergeRefs, useRole, useTypeahead } from '@floating-ui/react';
import { Divider } from 'antd';
import { forwardRef, useCallback, useEffect, useRef, useState } from 'react';
import { ConfigProvider } from '..';
import MenuItem from "./MenuItem";
import { useStyles } from "./style";

/**
 * @description 右键菜单的属性
 */
import { jsx as _jsx } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
var MenuComponent = /*#__PURE__*/forwardRef(function (_ref, forwardedRef) {
  var items = _ref.items,
    label = _ref.label,
    container = _ref.container,
    props = _objectWithoutProperties(_ref, _excluded);
  var _useStyles = useStyles(),
    styles = _useStyles.styles;
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    isOpen = _useState2[0],
    setIsOpen = _useState2[1];
  var _useState3 = useState(null),
    _useState4 = _slicedToArray(_useState3, 2),
    activeIndex = _useState4[0],
    setActiveIndex = _useState4[1];
  var _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    allowHover = _useState6[0],
    setAllowHover = _useState6[1];
  var listItemsRef = useRef([]);
  var listContentRef = useRef(items.map(function (item) {
    return item.label;
  }));
  var allowMouseUpCloseRef = useRef(false);
  var tree = useFloatingTree();
  var nodeId = useFloatingNodeId();
  var parentId = useFloatingParentNodeId();
  var isNested = parentId !== null;
  var _useFloating = useFloating({
      nodeId: nodeId,
      open: isOpen,
      onOpenChange: setIsOpen,
      placement: isNested ? 'right-start' : 'bottom-start',
      middleware: [offset({
        mainAxis: isNested ? 0 : 4,
        alignmentAxis: isNested ? -4 : 0
      }), flip(), shift()],
      whileElementsMounted: autoUpdate
    }),
    refs = _useFloating.refs,
    context = _useFloating.context,
    floatingStyles = _useFloating.floatingStyles;
  var hover = useHover(context, {
    enabled: isNested && allowHover,
    delay: {
      open: 75
    },
    handleClose: safePolygon({
      blockPointerEvents: true
    })
  });
  var click = useClick(context, {
    event: 'mousedown',
    toggle: !isNested || !allowHover,
    ignoreMouse: isNested
  });
  var role = useRole(context, {
    role: 'menu'
  });
  var dismiss = useDismiss(context);
  var listNavigation = useListNavigation(context, {
    listRef: listItemsRef,
    activeIndex: activeIndex,
    nested: isNested,
    onNavigate: setActiveIndex
  });
  var typeahead = useTypeahead(context, {
    enabled: isOpen,
    listRef: listContentRef,
    onMatch: isOpen ? setActiveIndex : undefined,
    activeIndex: activeIndex
  });
  var _useInteractions = useInteractions([hover, click, role, dismiss, listNavigation, typeahead]),
    getReferenceProps = _useInteractions.getReferenceProps,
    getFloatingProps = _useInteractions.getFloatingProps,
    getItemProps = _useInteractions.getItemProps;

  // Event emitter allows you to communicate across tree components.
  // This effect closes all menus when an item gets clicked anywhere
  // in the tree.
  useEffect(function () {
    if (!tree) return;
    function handleTreeClick() {
      setIsOpen(false);
    }
    function onSubMenuOpen(event) {
      if (event.nodeId !== nodeId && event.parentId === parentId) {
        setIsOpen(false);
      }
    }
    tree.events.on('click', handleTreeClick);
    tree.events.on('menuopen', onSubMenuOpen);
    return function () {
      tree.events.off('click', handleTreeClick);
      tree.events.off('menuopen', onSubMenuOpen);
    };
  }, [tree, nodeId, parentId]);
  useEffect(function () {
    if (isOpen && tree) {
      tree.events.emit('menuopen', {
        parentId: parentId,
        nodeId: nodeId
      });
    }
  }, [tree, isOpen, nodeId, parentId]);

  // Determine if "hover" logic can run based on the modality of input. This
  // prevents unwanted focus synchronization as menus open and close with
  // keyboard navigation and the cursor is resting on the menu.
  useEffect(function () {
    function onPointerMove(_ref2) {
      var pointerType = _ref2.pointerType;
      if (pointerType !== 'touch') {
        setAllowHover(true);
      }
    }
    function onKeyDown() {
      setAllowHover(false);
    }
    window.addEventListener('pointermove', onPointerMove, {
      once: true,
      capture: true
    });
    window.addEventListener('keydown', onKeyDown, true);
    return function () {
      window.removeEventListener('pointermove', onPointerMove, {
        capture: true
      });
      window.removeEventListener('keydown', onKeyDown, true);
    };
  }, [allowHover]);
  useEffect(function () {
    var timeout;
    function onContextMenu(e) {
      e.preventDefault();
      refs.setPositionReference({
        getBoundingClientRect: function getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            x: e.clientX,
            y: e.clientY,
            top: e.clientY,
            right: e.clientX,
            bottom: e.clientY,
            left: e.clientX
          };
        }
      });
      setIsOpen(true);
      clearTimeout(timeout);
      allowMouseUpCloseRef.current = false;
      timeout = window.setTimeout(function () {
        allowMouseUpCloseRef.current = true;
      }, 300);
    }
    function onMouseUp() {
      if (allowMouseUpCloseRef.current) {
        setIsOpen(false);
      }
    }
    document.addEventListener('contextmenu', onContextMenu);
    document.addEventListener('mouseup', onMouseUp);
    return function () {
      document.removeEventListener('contextmenu', onContextMenu);
      document.removeEventListener('mouseup', onMouseUp);
      clearTimeout(timeout);
    };
  }, [refs, container]);
  var renderMenuItem = useCallback(function (item, index) {
    // 支持渲染分割线
    if ('type' in item && item.type === 'divider') return /*#__PURE__*/_jsx(Divider, {
      style: {
        margin: '4px 12px',
        minWidth: 'auto',
        width: 'auto'
      }
    });
    var data = item;
    var props = _objectSpread({
      label: data.label,
      key: data.key,
      icon: data.icon,
      shortcut: data.shortcut,
      active: activeIndex === index
    }, getItemProps({
      ref: function ref(node) {
        listItemsRef.current[index] = node;
      },
      onClick: function onClick() {
        var _data$onClick;
        (_data$onClick = data.onClick) === null || _data$onClick === void 0 || _data$onClick.call(data);
        setIsOpen(false);
      },
      onMouseUp: function onMouseUp() {
        var _data$onClick2;
        (_data$onClick2 = data.onClick) === null || _data$onClick2 === void 0 || _data$onClick2.call(data);
        setIsOpen(false);
      }
    }));
    if ('children' in item) {
      return /*#__PURE__*/_jsx(MenuComponent, _objectSpread(_objectSpread({}, props), {}, {
        items: item.children
      }));
    }
    return /*#__PURE__*/_jsx(MenuItem, _objectSpread({}, props));
  }, [activeIndex]);
  var referenceRef = useMergeRefs([refs.setReference, forwardedRef]);
  return /*#__PURE__*/_jsxs(FloatingNode, {
    id: nodeId,
    children: [!label ? null : /*#__PURE__*/_jsx(MenuItem, _objectSpread(_objectSpread({
      label: label,
      nested: isNested,
      ref: referenceRef,
      role: isNested ? 'menuitem' : 'menu'
    }, props), getReferenceProps({
      onClick: function onClick(event) {
        event.stopPropagation();
      }
    }))), /*#__PURE__*/_jsx(FloatingPortal, {
      children: isOpen && /*#__PURE__*/_jsx(FloatingFocusManager, {
        context: context,
        initialFocus: isNested ? -1 : 0,
        modal: false,
        returnFocus: !isNested,
        children: /*#__PURE__*/_jsx("div", _objectSpread(_objectSpread({
          className: styles.container,
          ref: refs.setFloating,
          style: floatingStyles
        }, getFloatingProps()), {}, {
          children: items === null || items === void 0 ? void 0 : items.map(renderMenuItem)
        }))
      })
    })]
  });
});
var ContextMenu = /*#__PURE__*/forwardRef(function (props, ref) {
  return /*#__PURE__*/_jsx(ConfigProvider, {
    children: /*#__PURE__*/_jsx(FloatingTree, {
      children: /*#__PURE__*/_jsx(MenuComponent, _objectSpread(_objectSpread({}, props), {}, {
        ref: ref
      }))
    })
  });
});
export default ContextMenu;