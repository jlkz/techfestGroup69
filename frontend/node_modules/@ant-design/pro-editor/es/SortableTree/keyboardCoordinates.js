import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import { KeyboardCode, closestCorners, getFirstCollision } from '@dnd-kit/core';
import { getProjection } from "./utils/utils";
var directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
var horizontal = [KeyboardCode.Left, KeyboardCode.Right];
export var sortableTreeKeyboardCoordinates = function sortableTreeKeyboardCoordinates(context, indicator, indentationWidth) {
  return function (event, _ref) {
    var currentCoordinates = _ref.currentCoordinates,
      _ref$context = _ref.context,
      active = _ref$context.active,
      over = _ref$context.over,
      collisionRect = _ref$context.collisionRect,
      droppableRects = _ref$context.droppableRects,
      droppableContainers = _ref$context.droppableContainers;
    if (directions.includes(event.code)) {
      if (!active || !collisionRect) {
        return;
      }
      event.preventDefault();
      var _context$current = context.current,
        items = _context$current.items,
        offset = _context$current.offset;
      if (horizontal.includes(event.code) && over !== null && over !== void 0 && over.id) {
        var _getProjection = getProjection(items, active.id, over.id, offset, indentationWidth),
          depth = _getProjection.depth,
          maxDepth = _getProjection.maxDepth,
          minDepth = _getProjection.minDepth;
        switch (event.code) {
          case KeyboardCode.Left:
            if (depth > minDepth) {
              return _objectSpread(_objectSpread({}, currentCoordinates), {}, {
                x: currentCoordinates.x - indentationWidth
              });
            }
            break;
          case KeyboardCode.Right:
            if (depth < maxDepth) {
              return _objectSpread(_objectSpread({}, currentCoordinates), {}, {
                x: currentCoordinates.x + indentationWidth
              });
            }
            break;
        }
        return undefined;
      }
      var containers = [];
      droppableContainers.forEach(function (container) {
        if (container !== null && container !== void 0 && container.disabled || container.id === (over === null || over === void 0 ? void 0 : over.id)) {
          return;
        }
        var rect = droppableRects.get(container.id);
        if (!rect) {
          return;
        }
        switch (event.code) {
          case KeyboardCode.Down:
            if (collisionRect.top < rect.top) {
              containers.push(container);
            }
            break;
          case KeyboardCode.Up:
            if (collisionRect.top > rect.top) {
              containers.push(container);
            }
            break;
        }
      });
      var collisions = closestCorners({
        active: active,
        collisionRect: collisionRect,
        pointerCoordinates: null,
        droppableRects: droppableRects,
        droppableContainers: containers
      });
      var closestId = getFirstCollision(collisions, 'id');
      if (closestId === (over === null || over === void 0 ? void 0 : over.id) && collisions.length > 1) {
        closestId = collisions[1].id;
      }
      if (closestId && over !== null && over !== void 0 && over.id) {
        var activeRect = droppableRects.get(active.id);
        var newRect = droppableRects.get(closestId);
        var newDroppable = droppableContainers.get(closestId);
        if (activeRect && newRect && newDroppable) {
          var newIndex = items.findIndex(function (_ref2) {
            var id = _ref2.id;
            return id === closestId;
          });
          var newItem = items[newIndex];
          var activeIndex = items.findIndex(function (_ref3) {
            var id = _ref3.id;
            return id === active.id;
          });
          var activeItem = items[activeIndex];
          if (newItem && activeItem) {
            var _getProjection2 = getProjection(items, active.id, closestId, (newItem.depth - activeItem.depth) * indentationWidth, indentationWidth),
              _depth = _getProjection2.depth;
            var isBelow = newIndex > activeIndex;
            var modifier = isBelow ? 1 : -1;
            var newOffset = indicator ? (collisionRect.height - activeRect.height) / 2 : 0;
            var newCoordinates = {
              x: newRect.left + _depth * indentationWidth,
              y: newRect.top + modifier * newOffset
            };
            return newCoordinates;
          }
        }
      }
    }
    return undefined;
  };
};