import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _createForOfIteratorHelper from "@babel/runtime/helpers/esm/createForOfIteratorHelper";
var _navigator;
import { arrayMove } from '@dnd-kit/sortable';
import { flattenTree } from "./treeNode";
export var iOS = typeof navigator === 'undefined' ? false : /iPad|iPhone|iPod/.test((_navigator = navigator) === null || _navigator === void 0 ? void 0 : _navigator.platform);
function getDragDepth(offset, indentationWidth) {
  return Math.round(offset / indentationWidth);
}
export function getProjection(items, activeId, overId, dragOffset, indentationWidth) {
  var overItemIndex = items.findIndex(function (_ref) {
    var id = _ref.id;
    return id === overId;
  });
  var activeItemIndex = items.findIndex(function (_ref2) {
    var id = _ref2.id;
    return id === activeId;
  });
  var activeItem = items[activeItemIndex];
  var newItems = arrayMove(items, activeItemIndex, overItemIndex);
  var previousItem = newItems[overItemIndex - 1];
  var nextItem = newItems[overItemIndex + 1];
  var dragDepth = getDragDepth(dragOffset, indentationWidth);
  var projectedDepth = activeItem.depth + dragDepth;
  var maxDepth = getMaxDepth({
    previousItem: previousItem
  });
  var minDepth = getMinDepth({
    nextItem: nextItem
  });
  var depth = projectedDepth;
  if (projectedDepth >= maxDepth) {
    depth = maxDepth;
  } else if (projectedDepth < minDepth) {
    depth = minDepth;
  }
  return {
    depth: depth,
    maxDepth: maxDepth,
    minDepth: minDepth,
    parentId: getParentId()
  };
  function getParentId() {
    var _newItems$slice$rever;
    if (depth === 0 || !previousItem) {
      return null;
    }
    if (depth === previousItem.depth) {
      return previousItem.parentId;
    }
    if (depth > previousItem.depth) {
      return previousItem.id;
    }
    var newParent = (_newItems$slice$rever = newItems.slice(0, overItemIndex).reverse().find(function (item) {
      return item.depth === depth;
    })) === null || _newItems$slice$rever === void 0 ? void 0 : _newItems$slice$rever.parentId;
    return newParent !== null && newParent !== void 0 ? newParent : null;
  }
}
function getMaxDepth(_ref3) {
  var previousItem = _ref3.previousItem;
  if (previousItem) {
    return previousItem.depth + 1;
  }
  return 0;
}
function getMinDepth(_ref4) {
  var nextItem = _ref4.nextItem;
  if (nextItem) {
    return nextItem.depth;
  }
  return 0;
}
export function findItemDeep(items, itemId) {
  var _iterator = _createForOfIteratorHelper(items),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;
      var id = item.id,
        children = item.children;
      if (id === itemId) {
        return item;
      }
      if (children.length) {
        var child = findItemDeep(children, itemId);
        if (child) {
          return child;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return undefined;
}
function countChildren(items) {
  var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return items.reduce(function (acc, _ref5) {
    var children = _ref5.children;
    if (children.length) {
      return countChildren(children, acc + 1);
    }
    return acc + 1;
  }, count);
}
export function getChildCount(items, id) {
  var item = findItemDeep(items, id);
  return item ? countChildren(item.children) : 0;
}
export function removeChildrenOf(items, ids) {
  var excludeParentIds = _toConsumableArray(ids);
  return items.filter(function (item) {
    if (item.parentId && excludeParentIds.includes(item.parentId)) {
      if (item.children.length) {
        excludeParentIds.push(item.id);
      }
      return false;
    }
    return true;
  });
}
export var getFlattenedData = function getFlattenedData(treeData, activeId) {
  var flattenedTree = flattenTree(treeData);
  var collapsedItems = flattenedTree.reduce(function (acc, _ref6) {
    var children = _ref6.children,
      collapsed = _ref6.collapsed,
      id = _ref6.id;
    return collapsed && children.length ? [].concat(_toConsumableArray(acc), [id]) : acc;
  }, []);
  return removeChildrenOf(flattenedTree, activeId ? [activeId].concat(_toConsumableArray(collapsedItems)) : collapsedItems);
};